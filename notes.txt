luaL_dofile
[-0, +?, m]
int luaL_dofile (lua_State *L, const char *filename);
Loads and runs the given file. It is defined as the following macro:

(luaL_loadfile(L, filename) || lua_pcall(L, 0, LUA_MULTRET, 0))




        public bool DoFile(string file)
        {
            bool hasError = false;

            LuaStatus lstat = LoadFile(file); lua_load can return LUA_OK, LUA_ERRSYNTAX, or LUA_ERRMEM. 
            CheckLuaStatus(lstat);

            lstat = PCall(0, -1, 0);
            CheckLuaStatus(lstat);

It returns 0 (LUA_OK) if there are no errors, or 1 in case of errors.
            return hasError;
        }

        public bool DoString(string chunk)
        {
            bool hasError = false;

            LuaStatus lstat = LoadString(chunk); lua_load can return LUA_OK, LUA_ERRSYNTAX, or LUA_ERRMEM. 
            CheckLuaStatus(lstat);

            lstat = PCall(0, -1, 0);
            CheckLuaStatus(lstat);
            
It returns 0 (LUA_OK) if there are no errors, or 1 in case of errors.
            return hasError;
        }


        // these call native
        LuaStatus Load(LuaReader reader, IntPtr data, string chunkName, string mode)
        LuaStatus LoadBuffer(byte[] buffer, string? name, string? mode)
        LuaStatus LoadFile(string file, string? mode = null)

        LuaStatus PCall(int arguments, int results, int errorFunctionIndex)
        LuaStatus PCallK(int arguments, int results, int errorFunctionIndex, int context, LuaKFunction k)

        LuaStatus Resume(Lua from, int arguments, out int results)
        LuaStatus Resume(Lua? from, int arguments)


==============================================================================

package.path = "?;?.lua;C:\Dev\repos\Nebulua\KeraLuaEx\Test\scripts\*.lua"


ErrSyntax tb:"stack traceback:" | "[string "?"]:1: invalid escape sequence near ''?;?.lua;C:\D'" stack:"[string "?"]:1: invalid escape sequence near ''?;?.lua;C:\D'"


ArgumentException               Raised when a non-null argument that is passed to a method is invalid.
ArgumentNullException           Raised when null argument is passed to a method.
ArgumentOutOfRangeException     Raised when the value of an argument is outside the range of valid values.
DivideByZeroException           Raised when an integer value is divide by zero.
FileNotFoundException           Raised when a physical file does not exist at the specified location.
FormatException                 Raised when a value is not in an appropriate format to be converted from a string by a conversion method such as Parse.
IndexOutOfRangeException        Raised when an array index is outside the lower or upper bounds of an array or collection.
InvalidOperationException       Raised when a method call is invalid in an object's current state.
KeyNotFoundException            Raised when the specified key for accessing a member in a collection is not exists.
NotSupportedException           Raised when a method or operation is not supported.
NullReferenceException          Raised when program access members of null object.
OverflowException               Raised when an arithmetic, casting, or conversion operation results in an overflow.
OutOfMemoryException            Raised when a program does not get enough memory to execute the code.
StackOverflowException          Raised when a stack in memory overflows.
TimeoutException                The time interval allotted to an operation has expired.


===================================================================================

OO . and : https://www.lua.org/pil/16.html

The rather cool aspect of the 'LuaInterface' part is that reflection makes the C# binding almost trivial.

Debug is used during debugging. Trace is writing to the log file. It is kind of like logging. Both are very similar, but do tracing for long term retention, debugging for real time debugging.

https://github.com/dotnet/samples/tree/main/core/interop/cpp-cli


===================================================================================

